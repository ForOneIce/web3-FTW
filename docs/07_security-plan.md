# 安全计划

## 🔒 核心安全原则

### 时间处理
- **统一存储**: 所有时间统一存储为时间戳，避免异常的时间逻辑

### 资金处理
- **统一单位**: 统一使用单位wei，避免小数计算导致的异常

## 🔐 关卡密文安全流程

### 通关密文设计理念

1. **组织者输入**: 组织者输入的密码，只有组织者自己知道
2. **前端生成**: 前端生成的待验证密文只通过前端生成，不涉及网络请求和存储，除了组织者自己复制保存、用户通关后获取之外不暴露在其他地方
3. **链上存储**: 存储到合约的通关密文是待验证密文hash的结果，存储在链上，链上公开，等待闯关人提交验证（验证步骤即将用户提交的内容进行hash后对比和链上存储的是否一致）

> **重要**: 以上为本项目比较关键的安全设计点

---

## 🎯 普通模式

### 1. 组织者配置阶段

**组织者输入**: 原始密文 a（如："mypassword"）

**前端生成**:
- **主盐值**: masterSalt（32字符随机字符串）
- **关卡盐值**: levelSalt（16字符随机字符串）
- **密码原文**: y = a_level_1_masterSalt
- **挑战密文**: b = SHA256(y + levelSalt)（这是挑战者需要输入的密文）
- **前端计算**: c = keccak256(b)（存储到智能合约的哈希值）

**存储位置**:
- **智能合约存储**: 存储哈希值 c
- **后端存储**: 也存储哈希值 c（不存储明文）

### 2. 挑战者验证阶段

**挑战者获取**: 从组织者线下获取挑战密文 b（经过SHA256加密的密文）

**挑战者输入**: 在页面输入 b

**智能合约验证**:
```solidity
bytes32 passwordHash = keccak256(abi.encodePacked(_password));
require(passwordHash == challenge.passwordHash, "Incorrect password");
```

### 🔒 安全特性

- **每个关卡独立盐值**: 挑战者无法推测其他关卡密文
- **主盐值增加安全性**: 即使知道算法也无法破解
- **双层哈希**: SHA256 + keccak256，增加破解难度
- **后端不存储明文**: 只存储最终哈希值
- **智能合约验证**: 确保密码正确性

### 📊 数据流程

**配置时**: `a → y → b → c → 存储到合约和数据库`

**验证时**: `挑战者输入 b → 合约计算 keccak256(b) → 与存储的 c 比较`

### ✅ 安全优势

这样的设计确实更安全，因为：
- 每个关卡都有独立的盐值，挑战者拿到一个关卡的密文无法推测其他关卡
- 主盐值增加了整体安全性
- 双层哈希增加了破解难度
- 即使知道算法和部分密文，也无法破解其他关卡

---

## 🚀 高级模式

### 设计目标
防止参与者之间作弊，针对不同关卡的不同用户生成唯一的待验证通关密文。

### 实现方式
底层的密文逻辑与普通模式一致，但在生成过程中加入用户特定的标识，确保每个用户的密文都是唯一的。

---

## 📋 安全检查清单

- [ ] 时间戳统一处理
- [ ] 资金单位统一为wei
- [ ] 密码不存储明文
- [ ] 使用双层哈希加密
- [ ] 每个关卡独立盐值
- [ ] 智能合约权限验证
- [ ] 前端输入验证
- [ ] 后端数据验证
- [ ] 事件日志记录
- [ ] 异常处理机制